const superagent = require('superagent')
const path = require('path')
const fs = require('fs')

const TURBO_URL = 'https://turbo-dashboard.herokuapp.com'
const PLATFORM_VERCTOR_URL = 'https://platform.turbo360-vector.com'
const NODE_MODULES_PATH = (process.platform == 'win32') ? 'node_modules\\vertex360\\dist\\vertex' : 'node_modules/vertex360/dist/vertex'
const STANDARD_HEADERS = {'Content-Type':'application/json'}
const BUCKET = 'turbo360-vertex'

let currentSite = null

const generateErrorCallback = (err, statusCode, headers) => {
	const resHeaders = headers || STANDARD_HEADERS
	return {
		isBase64Encoded: false,
		statusCode: statusCode,
		headers: resHeaders,
		body: JSON.stringify({
			confirmation: 'fail',
			data: {
				message: err.message,
				stack: err.stack
			}
		})
	}
}

const generateSuccessCallback = (payload, headers) => {
	const resHeaders = headers || STANDARD_HEADERS
	return {
		isBase64Encoded: false,
		statusCode: 200,
		headers: resHeaders,
		body: JSON.stringify({
			confirmation: 'success',
			data: payload
		})
	}
}

const logString = (event) => {
	const method = event.httpMethod.toLowerCase() // get, post, put, delete
	let logText = method.toUpperCase()+' '+event.path
	if (event.headers['User-Agent'] != null)
		logText += ' '+event.headers['User-Agent']

	if (event.requestContext==null)
		return logText

	if (event.requestContext.identity==null)
		return logText

	if (event.requestContext.identity.sourceIp==null)
		return logText

	logText += ' '+event.requestContext.identity.sourceIp			
	return logText
}

const writeFile = function(filePath, data){
	return new Promise(function(resolve, reject){
		fs.writeFile(filePath, data, function(err) {
			if (err){
				reject(err)
				return
			}

			resolve(data)
			return
		})
	})
}

// confirms that TURBO_APP_ID and TURBO_APP_SLUG are defined
const isValidApp = (env) => {
    if (env.TURBO_APP_ID == null)
        return 'TURBO_APP_ID'

    if (env.TURBO_APP_ID == '<TURBO_APP_ID>')
        return 'TURBO_APP_ID'

    if (env.TURBO_APP_ID.length < 20)
        return 'TURBO_APP_ID'
    
    if (env.TURBO_APP_SLUG == null)
        return 'TURBO_APP_SLUG'

    if (env.TURBO_APP_SLUG == '<TURBO_APP_SLUG>')
        return 'TURBO_APP_SLUG'

    if (env.TURBO_APP_SLUG.length < 6)
        return 'TURBO_APP_SLUG'

    if (env.TURBO_API_KEY == null)
        return 'TURBO_API_KEY'

    if (env.TURBO_API_KEY == '<TURBO_API_KEY>')
        return 'TURBO_API_KEY'

    if (env.TURBO_API_KEY.length < 20)
        return 'TURBO_API_KEY'

    return null
}

const getRequest = (url, params, headers) => {
  if (headers == null)
    headers = {'Accept':'application/json'}

  return new Promise((resolve, reject) => {
    superagent.get(url)
    .query(params)
    .set(headers)
    .end((err, response) => {
      if (err){
        reject(err)
        return
      }

      // const payload = response.body || response.text
      let payload = null
      if (headers.Accept == 'application/json')
        payload = response.body || response.text

      resolve(payload)
    })
  })
}

const postRequest = (endpoint, params, headers) => {
	if (headers == null)
    headers = {'Accept':'application/json'}

	return new Promise((resolve, reject) => {
		superagent.post(endpoint)
		.send(params)
		.set(headers)
		.end((err, response) => {
			if (err){
				reject(err)
				return
			}

			// const payload = res.body || res.text
      let payload = null
      if (headers.Accept == 'application/json')
        payload = response.body || response.text

			resolve(payload)
		})
	})
}

const putRequest = (endpoint, body, headers) => {
	if (headers == null)
    headers = {'Accept':'application/json'}

	return new Promise((resolve, reject) => {
		superagent.put(endpoint)
		.send(body)
		.set(headers)
		.end((err, response) => {
			if (err){
				reject(err)
				return
			}

      let payload = null
      if (headers.Accept == 'application/json')
        payload = response.body || response.text

			resolve(payload)
		})
	})
}

const fetchTextFile = (url) => {
  return new Promise((resolve, reject) => {
    superagent.get(url).query(null)
    .end((err, res) => {
      if (err){
        reject(err)
        return
      }

      resolve(res.text)
    })
  })
}

const resetPage = (pageName, appslug) => {
  return new Promise(function(resolve, reject){
    if (pageName==null){
      reject(new Error('Missing pageName argument'))
      return
    }

    if (appslug==null){
      reject(new Error('Missing appslug argument'))
      return
    }

    var filename = pageName+'.txt'
    var page_url = 'https://s3.amazonaws.com/turbo360-vertex/pages/'+appslug+'/'+filename

    fetchTextFile(page_url)
    .then(function(data) {
      fs.writeFileSync('/tmp/'+filename, data)
      var parsed = JSON.parse(data)
      resolve(parsed)
    })
    .catch(function(err) {
      reject(err)
    })
  })
}

const fetchSite = (siteId, useCache) => {
  if (useCache == null) // default to true for using cache
    useCache = true

  return new Promise((resolve, reject) => {
    if (currentSite!=null && useCache==true){ // defer to cached site:
      resolve(currentSite)
      return
    }

    const endpoint = TURBO_URL + '/api/site/' + siteId
    superagent.get(endpoint).query(null)
    .set('Accept', 'application/json')
    .end((err, response) => {
      if (err){
        reject(err)
        return
      }

      const body = response.body
      if (body.confirmation != 'success'){
        reject(new Error(body.message))
        return
      }

      currentSite = body.result
      resolve(currentSite)
    })
  })
}

const globalConfig = (env) => {
    return new Promise(function(resolve, reject){
        if (env.TURBO_ENV == 'dev'){ // local version, fetch file. no need to validate app credentials
            // TODO: another filepath for windows
            const filePath = path.join(__dirname, '/pages/global.json').replace(NODE_MODULES_PATH, '')

            fs.readFile(filePath, 'utf8', (err, data) => {
                if (err) {
                    reject(err)
                    return
                }

                try {
                    resolve(JSON.parse(data))
                }
                catch(err){
                    reject(err)
                }
            })

            return
        }

        const missingKey = isValidApp(env)
        if (missingKey != null){
            reject(new Error('Please Set Your '+missingKey))
            return
        }

        fetchSite(env.TURBO_APP_ID, false) // fetch site first
        .then(site => {
            if (site.api.key != env.TURBO_API_KEY){
                reject(new Error('Unauthorized'))
                return
            }

            currentSite = site
            resolve(site.globalConfig)
        })
        .catch(err => {
            reject(err)
        })
    })
}

const proxyPlatformFunction = (endpoint, params, headers) => {
    return new Promise((resolve, reject) => {
        if (headers==null)
          headers = {'Accept': 'application/json'}

        const platformEndpoint = PLATFORM_VERCTOR_URL+'/'+endpoint
        superagent.post(platformEndpoint)
        .send(params)
        .set(headers)
        // .set('Accept', 'application/json')
        .end((err, response) => {
            if (err){
            reject(err)
            return
            }

            const payload = response.body
            resolve(payload)
        })
    })
}

// if there is a json config file in 'pages' folder,
// check 'tmp' directory for config file. If not there,
// download it and write data to 'tmp' directory
const checkPageConfig = function(template, appSlug){
	const basePath = __dirname.replace('node_modules/vertex360/dist/vertex', '')
	return new Promise(function(resolve, reject){
		const filePath = basePath+'/pages/'+template+'.json'
		// no config file set at all. this happens on non-vertex sites,
		// base Turbo 360 sites with no page configuration:
		if (fs.existsSync(filePath)==false){
			resolve(null)
			return
		}

		// check tmp dir for config file. if not there, fetch it.
		// not sure why this has to be only a relative filepath
		// while the others are full paths.
		const tmpFilePath = '/tmp/'+template+'.txt'
		if (fs.existsSync(tmpFilePath)){ // file found in tmp
			const pageConfig = fs.readFileSync(tmpFilePath, 'utf8')
			try {
				const pageJSON = JSON.parse(pageConfig)
				resolve(pageJSON)
				return
			}
			catch(err){ // most likely invalid JSON
				resolve(null)
				return
			}

			return
		}

		// config file not found in tmp directory, need to fetch:
		const page_url = 'https://s3.amazonaws.com/'+BUCKET+'/pages/'+appSlug+'/'+template+'.txt'
		var parsed = null
		fetchTextFile(page_url)
		.then(data => {
			parsed = JSON.parse(data)
			return writeFile(tmpFilePath, data) // cache in tmp directory
		})
		.then(data => {
			resolve(parsed)
		})
		.catch(err => {
			// resolve(null)
			if (err.message != null){
				// this means the corresponding page config file was not
				// found and should return a message that indicates such:
				if (err.message == 'Forbidden'){
					const jsonFileName = template+'.json'
					const msg = template+' config file ('+jsonFileName+') not found on staging environment. To fix: $ turbo page '+template+'. REFERENCE - https://docs.turbo360.co/page-configuration'
					reject(new Error(msg))
					return
				}
			}

			reject(err)
		})
	})
}

const parseBody = (event) => {
    if (event.body == null)
        return null

    let body = {}
    try { // this may come in as stringified json: "{\"name\":\"lebronjames\",\"email\":\"lebronjames@gmail.com\"}"
        body = JSON.parse(event.body)
    }
    catch(err){ // might be url-formatted: "name=dkwon&email=123" - this is how it comes back from a <form> field
        let parts = event.body.split('&')
        parts.forEach((keyValue, i) => {
            let keyValueParts = keyValue.split('=')
            if (keyValueParts.length == 2)
                body[keyValueParts[0]] = decode(keyValueParts[1])
        })
    }

    return body
}

module.exports = {
  get: getRequest,
  post: postRequest,
  put: putRequest,
  fetchTextFile: fetchTextFile,
  writeFile: writeFile,
  fetchSite: fetchSite,
  globalConfig: globalConfig,
  isValidApp: isValidApp,
  resetPage: resetPage,
  logString: logString,
  generateSuccessCallback: generateSuccessCallback,
  generateErrorCallback: generateErrorCallback,
  checkPageConfig: checkPageConfig,
  parseBody: parseBody,
  slugVersion: (text, numRandomChars) => {
  	let slug = text.toString().toLowerCase()
  			.replace(/\s+/g, '-')           // Replace spaces with -
  			.replace(/[^\w\-]+/g, '')       // Remove all non-word chars
  			.replace(/\-\-+/g, '-')         // Replace multiple - with single -
  			.replace(/^-+/, '')             // Trim - from start of text
  			.replace(/-+$/, '');            // Trim - from end of text

  	if (numRandomChars == null)
  		return slug.toLowerCase()

  	if (numRandomChars <= 0)
  		return slug.toLowerCase()

  	var randomString = ''
  	var possible = 'abcdefghijklmnopqrstuvwxyz0123456789'
  	for (var i=0; i <numRandomChars; i++)
  		randomString += possible.charAt(Math.floor(Math.random() * possible.length))

  	return slug.toLowerCase()+'-'+randomString
  },

  truncateText: (text, limit) => {
  	if (text.length < limit)
  		return text

  	return text.substring(0, limit)+'...'
  },

  // human readable date
  formattedDate: (date) => {
    const options = {weekday:'long', year:'numeric', month:'long', day:'numeric'}
    if (date == null)
      date = new Date()
    return date.toLocaleDateString('en-US', options) // Monday, May 6, 2019
  },

  // receives text and return truncated preview:
  scrapePreview: (text, limit, headers) => {
    return proxyPlatformFunction('scrapepreview', {text:text, limit:limit}, headers)
  },

  execute: (endpoint, params, headers) => {
    return proxyPlatformFunction(endpoint, params, headers)
  }
}
