const cookie = require('cookie') // https://www.npmjs.com/package/cookie
const sessions = require('client-sessions')
const utils = require('./utils')

const COOKIE_NAME = 'vertexSession'
const VERTEX360_URL = 'https://vertex360.herokuapp.com'

const parseBody = (event) => {
    if (event.body == null)
        return null

    let body = {}
    try { // this may come in as stringified json: "{\"name\":\"lebronjames\",\"email\":\"lebronjames@gmail.com\"}"
        body = JSON.parse(event.body)
    }
    catch(err){ // might be url-formatted: "name=dkwon&email=123" - this is how it comes back from a <form> field
        let parts = event.body.split('&')
        parts.forEach((keyValue, i) => {
            let keyValueParts = keyValue.split('=')
            if (keyValueParts.length == 2)
                body[keyValueParts[0]] = decode(keyValueParts[1])
        })
    }

    return body
}

const parseSession = (event, cookieName) => {
    return new Promise((resolve, reject) => {
        var ck = event.headers['Cookie'] // "cookie": "_ga=GA1.2.1640725716.1495418605; _gid=GA1.2.1387035527.1508298483; vertexSession=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
        if (ck == null){
            resolve(null)
            return
        }

        var cookies = cookie.parse(ck) // https://www.npmjs.com/package/cookie
        if (cookies[cookieName] == null){
            resolve(null)
            return
        }

        try {
            const decoded = sessions.util.decode({cookieName:cookieName, secret:'abc'}, cookies[cookieName])
            if (decoded == null){ // failed, no session cookie
                resolve(null)
                return
            }

            if (decoded.content == null){ // failed, no session cookie
                resolve(null)
                return
            }

            var vertexSession = JSON.parse(decoded.content)
            resolve(vertexSession)
        }
        catch(err){
            reject(err)
            return
        }
    })
}

const validateRequest = (event) => {
    const user = parseBody(event)
    if (user==null){
        // reject(new Error('Missing post body.'))
        throw new Error('Missing post body.')
        return 
    }

    const token = event.headers['VERTEX-TOKEN'] || event.headers['vertex-token']
    if (token==null){
        // reject(new Error('Invalid request.'))
        throw new Error('Invalid request.')
        return
    }

    return {user:user, token:token}
}

const generateCookieString = (cookieName, session) => {
    if (session == null){ // clear cookie
    	const clearCookieString = cookieName+'=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT'
        return clearCookieString
    }

    const sessionToken = JSON.stringify(session)
    // var encoded = sessions.util.encode({cookieName:SESSION_COOKIE_NAME, secret:'abc'}, sessionToken, null, null)
    // headers['Set-Cookie'] = SESSION_COOKIE_NAME+'='+encoded+'; path=/;' // always set to base path

    // const duration = 14*(24*60*60*1000) // 2 week default duration
    // const createdAt = new Date().getTime()
    // const encoded = sessions.util.encode({cookieName:cookieName, secret:'abc'}, sessionToken, duration, createdAt)

    // headers['Set-Cookie'] = cookieName+'='+encoded+'; path=/;' // always set to base path
    // const cookieString = cookieName+'='+encoded+'; path=/;' // always set to base path

    const encoded = sessions.util.encode({cookieName:cookieName, secret:'abc'}, sessionToken, null, null)
    const cookieString = cookieName+'='+encoded+'; path=/; max-age=1209600' // default max-age to 2 weeks (seconds)
    return cookieString
}

// register, login, logout, currentuser:
module.exports = (event) => {
    return new Promise((resolve, reject) => {
        /** "/auth/register"
            "/auth/login"
            "/auth/logout"
            "/auth/currentuser" */
        const requestPath = event.path
        const parts = requestPath.split('/')
        const pathParts = []
		const method = event.httpMethod.toLowerCase() // get, post, put, delete

        parts.forEach(entry => {
            if (entry.length>0 && entry!='/')
                pathParts.push(entry)
        })

        if (pathParts.length != 2){
            reject(new Error('invalid path. must folow /auth/:action'))
            return
        }

        // invalid. must be 'auth'
        if (pathParts[0] != 'auth'){
            reject(new Error('invalid path. must folow /auth/:action'))
            return
        }

        const authRequest = {method:method, event:event}
        const action = pathParts[1]

        if (action=='login'){
            let reqObject = null
            try {
                reqObject = validateRequest(event)
            }
            catch(err){
                reject(err)
                return
            }

            // verifyUser against vertex service:
            utils.post(VERTEX360_URL+'/account/verifytoken', {profile:reqObject.user.id, token:reqObject.token})
            .then(payload => {
                if (payload.confirmation != 'success'){
                    throw new Error(payload.message)
                    return
                }

                resolve({
                    vertexUser: payload.user,
                    cookie: generateCookieString(COOKIE_NAME, {vertexUser:payload.user})
                })
            })
            .catch(function(err){
                reject(err)
            })

            return
        }

        if (action=='token'){
            const body = parseBody(event) // {token:"123abc..."}
            if (body == null){
                reject(new Error('Missing post body.'))
                return
            }

            body['encode'] = 'base64'

            // verifyUser against vertex service:
            utils.post(VERTEX360_URL+'/account/verifytoken', body)
            .then(payload => {
                if (payload.confirmation != 'success'){
                    throw new Error(payload.message)
                    return
                }

                resolve({
                    vertexUser: payload.user,
                    cookie: generateCookieString(COOKIE_NAME, {vertexUser:payload.user})
                })
            })
            .catch(function(err){
                reject(err)
            })

            return
        }

        // verifyUser against vertex service:
        if (action=='register'){
            let reqObject = null
            try {
                reqObject = validateRequest(event)
            }
            catch(err){
                reject(err)
                return
            }

            utils.post(VERTEX360_URL+'/account/verifytoken', {profile:reqObject.user.id, token:reqObject.token})
            .then(payload => {
                if (payload.confirmation != 'success'){
                    throw new Error(payload.message)
                    return
                }

                // resolve(payload.user)
                resolve({
                    vertexUser: payload.user,
                    cookie: generateCookieString(COOKIE_NAME, {vertexUser:payload.user})
                })
            })
            .catch(function(err){
                reject(err)
            })

            // const user = parseBody(event)
            // if (user==null){
            //     reject(new Error('Missing post body.'))
            //     return
            // }

            // const vertexSession = {vertexUser:user}
            // resolve({
            //     vertexUser: user,
            //     cookie: generateCookieString(COOKIE_NAME, vertexSession)
            // })
            
            return
        }

        if (action=='currentuser'){
            parseSession(event, COOKIE_NAME)
            .then(session => { // session can be null
                const vertexUser = (session) ? session.vertexUser : null
                resolve({
                    vertexUser: vertexUser,
                    cookie: null
                })

                return
            })
            .catch(err => {
                resolve({
                    vertexUser: null,
                    cookie: null
                })

                return
            })
            
            return
        }

        if (action=='logout'){
            resolve({
                vertexUser: null,
                cookie: generateCookieString(COOKIE_NAME, null) // reset string goes here
            })
            
            return
        }

        reject(new Error('Invalid auth action: ' + action))
    })

}