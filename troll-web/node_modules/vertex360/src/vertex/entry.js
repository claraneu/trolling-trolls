const TaskMgr = require('./TaskMgr')
const base64 = require('js-base64').Base64
const serverless = require('serverless-http')
const adminHandler = require('./adminHandler')
const authHandler = require('./authHandler')
const utils = require('./utils')
const fs = require('fs')

const a = 'QVdTX0FDQ0VTU19LRVlfSUQsQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZLEFXU19TRVNTSU9OX1RPS0VOLE5PREVfUEFUSCxfWF9BTVpOX1RSQUNFX0lE'

module.exports = (app) => {
	try {
		const c = base64.decode(a).split(',')
		c.forEach(key => {
			delete process.env[key]
		})
	}
	catch(err) {

	}

	return (event, context, callback) => {
		context.callbackWaitsForEmptyEventLoop = false //defaults to true and will result in timeout

		const method = event.httpMethod.toLowerCase() // get, post, put, delete
		const turboVertexClient = event.headers['turbo-vertex-client']

		// these requests come from admin dashboard, turbo360.co or vertex360.co
		if (turboVertexClient=='admin-dashboard' || turboVertexClient=='mothership'){ // base turbo or vertex site
			adminHandler(app, event, callback)
			return
		}

		// these requests come from "platform" lambda:
		if (turboVertexClient=='platform'){
			if (method !== 'post') {
				callback(null, utils.generateErrorCallback(new Error('Invalid http method: '+method), 500))
				return
			}

			let body = null
			try {
				body = utils.parseBody(event)
			} catch (error) {
				callback(null, utils.generateErrorCallback(error, 500))
				return
			}

			const task = body.task
			if (task == null) {
				callback(null, utils.generateErrorCallback(new Error('Missing task parameter.'), 500))
				return
			}

			if (task === 'manifest') {
				callback(null, utils.generateSuccessCallback({
					sync: TaskMgr.sync || {},
					queue: TaskMgr.queue,
					executed: TaskMgr.executed,
					failed: TaskMgr.failed
				}))

				return
			}

			// sent from platform lambda asynchronously in order to keep the remote DB 
			// file ("posts.txt") in sync with the /tmp directory collection file ("posts.db"):
			if (task === 'sync-collection') {
				const collection = body.collection // name of collection, e.g. "post", "profile", etc
				if (collection == null) {
					callback(null, utils.generateErrorCallback(new Error('Missing collection parameter.'), 500))
					return
				}

				const destination = body.dest // upload url
				if (destination == null) {
					callback(null, utils.generateErrorCallback(new Error('Missing dest parameter.'), 500))
					return
				}

				// fetch collection .db file from tmp directory and return.
				const collectionName = collection.trim()
				const TMP_DIR = process.env.TMP_DIR || '/tmp'
				const tmpFilePath = TMP_DIR+'/'+collectionName+'.db'

				if (!fs.existsSync(tmpFilePath)) {
					callback(null, utils.generateErrorCallback(new Error('Collection not found: '+tmpFilePath), 500))
					return
				}

				// compact the DB file before sending:
				if (TaskMgr.dbRef) {
					// console.log('COMPACT DB: ' +JSON.stringify(Object.keys(TaskMgr.dbRef._collections.creators)))
					if (TaskMgr.dbRef._collections) {
						const collectionDB = TaskMgr.dbRef._collections[collectionName]
						if (collectionDB)
							collectionDB.persistence.compactDatafile()
					}
				}

				const now = new Date()
				const dbText = fs.readFileSync(tmpFilePath, 'utf8')
				utils.put(destination, dbText, {'Content-Type': 'text/plain'})
				.then(data => {
					if (TaskMgr.sync[collectionName])
						delete TaskMgr.sync[collectionName] // clear from static sync object

					const confirmation = collectionName+' successfully synced.'
					TaskMgr.executed.push(now.toString()+' - '+confirmation) // update Task Manager

					callback(null, utils.generateSuccessCallback({
						collection: collectionName,
						status: confirmation
					}))

					return
				})
				.catch(err => {
					const message = err.message || err
					TaskMgr.failed.push(now.toString()+' - '+collectionName+' sync failed: '+message)
					callback(null, utils.generateErrorCallback(err, 500))
					return
				})

				return
			}

			callback(null, utils.generateErrorCallback(new Error('Invalid task parameter: '+task), 500))
			return
		}

		if (turboVertexClient=='vertex-sdk'){
			const requestPath = event.path
			const pathParts = []
			const parts = requestPath.split('/')
			parts.forEach(entry => {
				if (entry.length>0 && entry!='/')
					pathParts.push(entry)
			})

			const payload = {message:'site pinged'}

			// ping site to keep awake
			if (pathParts.length==0){
				callback(null, utils.generateSuccessCallback(payload))
				return
			}

			// ping site to keep awake
			if (pathParts[0] == 'ping'){
				callback(null, utils.generateSuccessCallback(payload))
				return
			}

			// ping site to keep awake
			callback(null, utils.generateSuccessCallback(payload))
			return
		}

		if (turboVertexClient=='widget-auth'){
			authHandler(event)
			.then(payload => { // payload: {vertexUser:OBJECT, cookie:STRING}

				// take cookie string from payload and set headers arg:
				const headers = {'Content-Type': 'application/json'}

				if (payload.cookie != null)
					headers['Set-Cookie'] = payload.cookie

				callback(null, utils.generateSuccessCallback({vertexUser:payload.vertexUser}, headers))
			})
			.catch(err => {
				callback(null, utils.generateErrorCallback(err, 500))
			})

			return
		}

		// Sample Heroku log:
		// 2019-10-15T00:30:22.198651+00:00 app[web.1]: GET /apple-touch-icon-120x120-precomposed.png 404 0.467 ms - 179
		// if (app.opts.logging){
		// 	const logStmt = utils.logString(event)
		// 	console.log(logStmt)
		// }

		if (app.opts){
			if (app.opts.logging){
				const logStmt = utils.logString(event)
				console.log(logStmt)
			}
		}

		if (turboVertexClient=='widget')
            process.env['TURBO-VERTEX-CLIENT'] = turboVertexClient
        else
            delete process.env['TURBO-VERTEX-CLIENT']

		const handler = serverless(app)
		return handler(event, context, callback)
	}
}