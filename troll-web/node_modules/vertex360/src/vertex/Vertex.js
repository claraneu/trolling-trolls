// const decode = require('urldecode')
const formatCallback = require('./callback')
const adminRest = require('./adminRest')
const authHandler = require('./authHandler')
const Router = require('./Router')
const db = require('./db')

const generateErrorCallback = (err, statusCode, headers) => {
	const resHeaders = headers || {'Content-Type':'application/json'}
	return {
		isBase64Encoded: false,
		statusCode: statusCode,
		headers: resHeaders,
		// headers: {'Content-Type': 'application/json'},
		body: JSON.stringify({
			confirmation: 'fail',
			data: {
				message: err.message,
				stack: err.stack
			}
		})
	}
}

const generateSuccessCallback = (payload, headers) => {
	const resHeaders = headers || {'Content-Type':'application/json'}
	return {
		isBase64Encoded: false,
		statusCode: 200,
		headers: resHeaders,
		// headers: {'Content-Type':'application/json'},
		body: JSON.stringify({
			confirmation: 'success',
			data: payload
		})
	}
}

const logString = (event) => {
	const method = event.httpMethod.toLowerCase() // get, post, put, delete
	let logText = method.toUpperCase()+' '+event.path
	if (event.headers['User-Agent'] != null)
		logText += ' '+event.headers['User-Agent']

	if (event.requestContext==null)
		return logText

	if (event.requestContext.identity==null)
		return logText

	if (event.requestContext.identity.sourceIp==null)
		return logText

	logText += ' '+event.requestContext.identity.sourceIp			
	return logText

}

// this never runs on local so no need to worry about 'dev' vs 'prod'
// const checkCollectionDB = (collectionName, config) => {
//   	const collectionFilePath = TMP+'/'+collectionName+'.db'
//     return new Promise((resolve, reject) => {
//   		checkCollectionFile(collectionName, collectionFilePath)
//   		.then(data => { // load collection file from backing store if necessary
//   			return (data.found) ? null : this.turbo.loadCollection(collectionName, collectionFilePath, config['api_key'])
//   		})
//   		.then(data => {
//   			resolve(data)
//   		})
//   		.catch(err => {
//   			reject(err)
//   		})
//   	})
// }

class Vertex {
	constructor(opts){ // opts can be null
		this.routes = []
		this.middleware = []
		this.staticDir = 'public'
		this.opts = opts
		this.logging = false
		if (opts == null) // no config options
			return

		// Configure Options:
		this.staticDir = opts.static || 'public'
		this.logging = opts.logging || false

		// check if db connection required
		const dbConfiguration = opts.db // can be null
		if (dbConfiguration != null){
			if (dbConfiguration.type == null){ // default to mongo
				db.connectNedb(dbConfiguration.url, dbConfiguration.onError, dbConfiguration.onSuccess)
				// db.connect(dbConfiguration.url, dbConfiguration.onError, dbConfiguration.onSuccess)
			}
			else {
				db.connectNedb(dbConfiguration.url, dbConfiguration.onError, dbConfiguration.onSuccess)
			}
		}
	}

	expressVersion(app){ // app is an express app
		var _this = this
		app.use('/turbo', (req, res, next) => {
			res.json({
				confirmation: 'success',
				data: JSON.stringify(_this.routes)
			})
		})

		_this.routes.forEach((route) => {
			app.use(route.stem, (req, res, next) => {
				res.json({
					confirmation: 'success',
					data: route.stem
				})
			})
		})

		return app
	}

	useStatic(directory){
		this.staticDir = directory
	}

	use(pathOrFunc, routeHandler){
		if (routeHandler == null){ // add this to middleware array
			// TODO: make sure pathOrFunc is a function, not a string
			this.middleware.push(pathOrFunc)
			return
		}

		// TODO: make sure pathOrFunc is a string, not a function,
		routeHandler.setStem(pathOrFunc)
		this.routes.push(routeHandler)
	}

	get(path, requestHandler){ // direct path, no route handler passed in:
		var routeHandler = new Router()
		routeHandler.setStem('/') // default stem to '/'
		routeHandler.get(path, requestHandler)
		this.routes.push(routeHandler)
	}

	post(path, requestHandler){ // direct path, no route handler passed in:
		var routeHandler = new Router()
		routeHandler.setStem('/') // default stem to '/'
		routeHandler.post(path, requestHandler)
		this.routes.push(routeHandler)
	}

	// TDOD: these do not exist yet on the Router.js class. Have to implement:
	// put(path, requestHandler){ // direct path, no route handler passed in:
	// 	var routeHandler = new Router()
	// 	routeHandler.setStem('/') // default stem to '/'
	// 	routeHandler.put(path, requestHandler)
	// 	this.routes.push(routeHandler)
	// }

	// delete(path, requestHandler){ // direct path, no route handler passed in:
	// 	var routeHandler = new Router()
	// 	routeHandler.setStem('/') // default stem to '/'
	// 	routeHandler.delete(path, requestHandler)
	// 	this.routes.push(routeHandler)
	// }

	routeNotFound(event, msg){
		const method = event.httpMethod.toLowerCase() // get, post, put, delete
		var data = {
			isBase64Encoded: false,
			statusCode: 501,
			headers: {'Content-Type': 'application/json'},
			body: JSON.stringify({
				confirmation: 'fail',
				message: msg
			})
		}

		return data
	}

	// this is the main entry point of the app (see /src/vertex/entry.js) - it is called by the actual AWS Lambda entry from the www/bin.js file:
	handle(lambda_config){ // {event: event, context: context, callback: callback}
		const event = lambda_config.event
		const callback = lambda_config.callback
		const method = event.httpMethod.toLowerCase() // get, post, put, delete
		const turboVertexClient = event.headers['turbo-vertex-client']

		// these requests come from admin dashboard, turbo360.co or vertex360.co
		if (turboVertexClient=='admin-dashboard' || turboVertexClient=='mothership'){ // base turbo or vertex site
			const controllers = this.opts.controllers || null
			if (controllers == null){
				callback(null, generateErrorCallback(new Error('controllers not defined. check config settings.'), 500))
				return
			}

			adminRest(controllers, event)
			.then(payload => {
				callback(null, generateSuccessCallback(payload))
			})
			.catch(err => {
				callback(null, generateErrorCallback(err, 500))
			})

			return
		}

		if (turboVertexClient=='vertex-sdk'){
			const requestPath = event.path
			const pathParts = []
			const parts = requestPath.split('/')
			parts.forEach(entry => {
				if (entry.length>0 && entry!='/')
					pathParts.push(entry)
			})

			const payload = {message:'site pinged'}

			// ping site to keep awake
			if (pathParts.length==0){
				callback(null, generateSuccessCallback(payload))
				return
			}

			// ping site to keep awake
			if (pathParts[0] == 'ping'){
				callback(null, generateSuccessCallback(payload))
				return
			}

			// ping site to keep awake
			callback(null, generateSuccessCallback(payload))
			return
		}

		if (turboVertexClient=='widget-auth'){
			authHandler(event)
			.then(payload => { // payload: {vertexUser:OBJECT, cookie:STRING}

				// take cookie string from payload and set headers arg:
				const headers = {'Content-Type': 'application/json'}

				if (payload.cookie != null)
					headers['Set-Cookie'] = payload.cookie

				// callback(null, generateSuccessCallback(payload, headers))
				callback(null, generateSuccessCallback({vertexUser:payload.vertexUser}, headers))
			})
			.catch(err => {
				callback(null, generateErrorCallback(err, 500))
			})

			return
		}


		// Sample Heroku log:
		// 2019-10-15T00:30:22.198651+00:00 app[web.1]: GET /apple-touch-icon-120x120-precomposed.png 404 0.467 ms - 179
		if (this.logging){
			const logStmt = logString(event)
			console.log(logStmt)
		}

		if (method == 'post'){
			let pkg = null
			for (let i=0; i<this.routes.length; i++){
				let pathRouter = this.routes[i]
				if (pathRouter.handlePost(event) != null){
					pkg = pathRouter.handlePost(event)
					break
				}
			}

			if (pkg == null){
				callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
				return
			}

			formatCallback(event, callback, pkg.routeParams, this.opts, this.middleware, (err, formatted) => {
				if (err != null){
					callback(null, generateErrorCallback(err, 500))
					return
				}

				try {
					pkg.routeHandler(formatted.req, formatted.res)
				}
				catch(err){
					callback(null, generateErrorCallback(err, 500))
					return
				}
			})

			return
		}

		if (method == 'put'){
			let pkg = null
			for (let i=0; i<this.routes.length; i++){
				let pathRouter = this.routes[i]
				if (pathRouter.handlePut(event) != null){
					pkg = pathRouter.handlePut(event)
					break
				}
			}

			if (pkg == null){
				callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
				return
			}

			formatCallback(event, callback, pkg.routeParams, this.opts, this.middleware, (err, formatted) => {
				if (err != null){
					callback(null, generateErrorCallback(err, 500))
					return
				}

				try {
					pkg.routeHandler(formatted.req, formatted.res)
				}
				catch(err){
					callback(null, generateErrorCallback(err, 500))
					return
				}
			})

			return
		}

		if (method == 'delete'){
			let pkg = null
			for (let i=0; i<this.routes.length; i++){
				let pathRouter = this.routes[i]
				if (pathRouter.handleDelete(event) != null){
					pkg = pathRouter.handleDelete(event)
					break
				}
			}

			if (pkg == null){
				callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
				return
			}

			formatCallback(event, callback, pkg.routeParams, this.opts, this.middleware, (err, formatted) => {
				if (err != null){
					callback(null, generateErrorCallback(err, 500))
					return
				}

				try {
					pkg.routeHandler(formatted.req, formatted.res)
				}
				catch(err){
					callback(null, generateErrorCallback(err, 500))
					return
				}
			})

			return
		}

		if (method == 'get'){
			if (event.path.indexOf('.') == -1){
				let pkg = null
				for (let i=0; i<this.routes.length; i++){
					let pathRouter = this.routes[i]
					if (pathRouter.handleGet(event) != null){
						pkg = pathRouter.handleGet(event)
						break
					}
				}

				if (pkg == null){
					callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
					return
				}

				formatCallback(event, callback, pkg.routeParams, this.opts, this.middleware, (err, formatted) => {
					if (err != null){
						callback(null, generateErrorCallback(err, 500))
						return
					}

					try {
						pkg.routeHandler(formatted.req, formatted.res)
					}
					catch(err){
						callback(null, generateErrorCallback(err, 500))
						return
					}
				})

				return
			}

			// this is a static file, redirect to CDN:
			if (event.headers==undefined || event.headers==null){
				callback(null, {
					isBase64Encoded: false,
					statusCode: 500,
					headers: {'Content-Type': 'application/json'},
					body: JSON.stringify({
						confirmation: 'fail',
						data: 'Missing Turbo-Vertex-App header (headers is null)'
					})
				})

				return
			}

			const slug = event.headers['Turbo-Vertex-App']

			// USE CDN for static assets, e.g. - https://cdn.turbo360-vertex.com/dkwon-vertex-oienuk/public/images/pip.png
			const dir = this.staticDir || 'public' // default to public directory
			// const concat = 'cdn.turbo360-vertex.com/' + slug + '/' + dir + event.path
			// const url = concat.replace('//', '/') // this will happen if there is no static directory specified

			let url = null
			if (this.opts == null){ // default to Turbo CDN:
				if (slug == null){
					callback(null, {
						isBase64Encoded: false,
						statusCode: 500,
						headers: {'Content-Type': 'application/json'},
						body: JSON.stringify({
							confirmation: 'fail',
							data: 'Missing Turbo-Vertex-App header'
						})
					})

					return
				}

				const concat = 'cdn.turbo360-vertex.com/' + slug + '/' + dir + event.path
				url = concat.replace('//', '/') // this will happen if there is no static directory specified
			}
			else if (this.opts.bucket == null) { // default to Turbo CDN:
				if (slug == null){
					callback(null, {
						isBase64Encoded: false,
						statusCode: 500,
						headers: {'Content-Type': 'application/json'},
						body: JSON.stringify({
							confirmation: 'fail',
							data: 'Missing Turbo-Vertex-App header'
						})
					})

					return
				}

				const concat = 'cdn.turbo360-vertex.com/' + slug + '/' + dir + event.path
				url = concat.replace('//', '/') // this will happen if there is no static directory specified
			}
			else { // custom bucket, doesn't require Turbo-Vertex-App header
				url = 's3.amazonaws.com/' + this.opts.bucket + '/' + dir + event.path // e.g. - https://s3.amazonaws.com/turbo-demo-1/public/images/turbo.png
			}

			// redirect to CDN:
			callback(null, {
				isBase64Encoded: false,
				statusCode: 301,
				headers: {'Location': 'https://'+url},
				body: ''
			})
		}
	}
}

module.exports = Vertex
