'use strict'
const fs = require('fs')
const Mustache = require('mustache')
const path = require('path')
const cookie = require('cookie') // https://www.npmjs.com/package/cookie
const sessions = require('client-sessions')
const decode = require('urldecode')
const recursive = require("recursive-readdir")
const utils = require('./utils')
const BUCKET = 'turbo360-vertex'


/* IMPORTANT: the state of these variables are maintained in between multiple requests so if you need to "reset" after
	sending back a response, make sure to do so (see setVertexSession() - shouldClearSession is reset to false) */
const SESSION_COOKIE_NAME = 'vertexSession'
let shouldClearSession = false

// object observer for vertexSession:
const proxyVertexSession = function(vertexSession, req){ // http://blog.revathskumar.com/2016/02/es6-observe-change-in-object-using-proxy.html
	const handler = {
		set: function(target, key, value){
			if (target != vertexSession)
				return

			req.vertexSessionChanged = true
			target[key] = value
		}
	}

	return new Proxy(vertexSession, handler)
}

const readFile = function(filePath){
	return new Promise(function(resolve, reject){
		fs.readFile(filePath, 'utf8', function(err, file){
			if (err){
				reject(new Error('File Not Found: ' + filePath))
				return
			}

			resolve(file)
		})
	})
}

const writeFile = function(filePath, data){
	return new Promise(function(resolve, reject){
		fs.writeFile(filePath, data, function(err) {
			if (err){
				reject(err)
				return
			}
	
			resolve(data)
			return
		})
	})
}

const readRecursiveDirectories = function(directory){
	return new Promise(function(resolve, reject){
		var formatted = []
		if (!fs.existsSync(directory)){
			resolve(formatted)
			return
		}

		recursive(directory, function(err, files) {
			if (err){
				reject(err)
				return
			}

			// `files` is an array of file paths. Includes
			// all files under subdirectories as well
			// console.log(files);
			/*
				['views/partials/footer.mustache',
				'views/partials/head.mustache',
				'views/partials/header.mustache',
				'views/partials/scripts.mustache',
				'views/partials/blocks/hero.mustache']
			*/
			
			// var formatted = []
			files.forEach(function(filePath){
				var fileInfo = {}
				fileInfo['path'] = filePath
				var parts = filePath.split('/')
				var name = parts[parts.length-1]
				// name = name.split('.')[0]
				fileInfo['name'] = name.split('.')[0]
				formatted.push(fileInfo)
			})

			resolve(formatted)
		})
	})
}

const renderMustache = function(pkg){
	return new Promise(function(resolve, reject){
		var template = pkg.template
		if (template == null){
			reject(new Error('Missing template'))
			return
		}

		var data = pkg.data
		if (data == null){
			reject(new Error('Missing data'))
			return
		}

		var partials = pkg.partials || {} // can be null

		try {
			var props = data || {} // have to insert something here otherwise it crashes Mustache.render()
			var html = Mustache.render(template, props, partials)
			resolve(html)
		}
		catch(err) {
			reject(err)
		}
	})
}

const getCookieName = function(opts){
	let cookieName = SESSION_COOKIE_NAME
	if (opts != null){
		if (opts.session != null){
			cookieName = opts.session.cookieName || SESSION_COOKIE_NAME
		}
	}

	return cookieName
}

const setVertexSession = function(req, headers, opts){ // opts can be null
	let cookieName = getCookieName(opts)
	if (shouldClearSession == true){ // clear session:
		// https://stackoverflow.com/questions/5285940/correct-way-to-delete-cookies-server-side
		// headers['Set-Cookie'] = SESSION_COOKIE_NAME+'=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT'
		headers['Set-Cookie'] = cookieName+'=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT'
		shouldClearSession = false
		return headers
	}

	if (req.vertexSessionChanged == false) // no change to session, don't reset cookie
		return headers

	// var vertexSession = req.vertexSession || {} // just in case
	var vertexSession = req[cookieName] || {} // just in case

	delete vertexSession['reset'] // remove this because it's not set by the user
	if (Object.keys(vertexSession).length == 0) // nothing changed in session - don't do anything.
		return headers

	// headers['Set-Cookie'] = 'vertexSession=' + sessionToken + '; HttpOnly; Path=/'
	// this comes back in the req.headers.Cookie object like so: "vertexSession={\"user\":{\"id\":\"123123\",\"username\":\"danpatrick\"}}"

	var sessionToken = JSON.stringify(vertexSession)
	// var encoded = sessions.util.encode({cookieName:SESSION_COOKIE_NAME, secret:'abc'}, sessionToken, null, null)
	// headers['Set-Cookie'] = SESSION_COOKIE_NAME+'='+encoded+'; path=/;' // always set to base path

	var encoded = sessions.util.encode({cookieName:cookieName, secret:'abc'}, sessionToken, null, null)
	headers['Set-Cookie'] = cookieName+'='+encoded+'; path=/;' // always set to base path
	return headers
}

// if there is a json config file in 'pages' folder,
// check 'tmp' directory for config file. If not there,
// download it and write data to 'tmp' directory
const checkPageConfig = function(template, appSlug){
	const basePath = __dirname.replace('node_modules/vertex360/dist/vertex', '')
	return new Promise(function(resolve, reject){
		const filePath = basePath+'/pages/'+template+'.json'
		// no config file set at all. this happens on non-vertex sites,
		// base Turbo 360 sites with no page configuration:
		if (fs.existsSync(filePath)==false){ 
			resolve(null)
			return	
		}

		// check tmp dir for config file. if not there, fetch it.
		// not sure why this has to be only a relative filepath
		// while the others (see line 184) are full paths.
		const tmpFilePath = '/tmp/'+template+'.txt'
		if (fs.existsSync(tmpFilePath)){ // file found in tmp
			const pageConfig = fs.readFileSync(tmpFilePath, 'utf8')
			try {
				const pageJSON = JSON.parse(pageConfig)
				resolve(pageJSON)
				return
			}
			catch(err){ // most likely invalid JSON (see line 199)
				resolve(null)
				return	
			}
			return	
		}

		// config file not found in tmp directory, need to fetch:
		const page_url = 'https://s3.amazonaws.com/'+BUCKET+'/pages/'+appSlug+'/'+template+'.txt'
		var parsed = null
		utils.fetchTextFile(page_url)
		.then(data => {
			parsed = JSON.parse(data)
			return writeFile(tmpFilePath, data) // cache in tmp directory
		})
		.then(data => {
			resolve(parsed)
		})
		.catch(err => {
			// resolve(null)
			if (err.message != null){
				// this means the corresponding page config file was not
				// found and should return a message that indicates such:
				if (err.message == 'Forbidden'){
					const jsonFileName = template+'.json'
					const msg = template+' config file ('+jsonFileName+') not found on staging environment. To fix: $ turbo page '+template+'. REFERENCE - https://docs.turbo360.co/page-configuration'
					reject(new Error(msg))
					return
				}
			}

			reject(err)
		})	
	})
}

const configureResponse = function(req, callback, opts){ // opts can be null
	let viewsDir = 'views'
	if (opts != null)
		viewsDir = opts.views || 'views'

	var res = {
		statusCode: 200,
		setHeader: function(key, value){
			var headers = {}
			headers[key] = value
		},

		json: function(data){
			var headers = {'Content-Type': 'application/json'}
			callback(null, {
				isBase64Encoded: false,
				statusCode: 200,
				// headers: setVertexSession(req, headers, opts),
				headers: headers,
				body: JSON.stringify(data)
			})
		},

		data: function(data){
			data['req'] = req
			callback(null, {
				isBase64Encoded: false,
				statusCode: 200,
				headers: {'Content-Type': 'application/json'},
				body: JSON.stringify(data)
			})
		},

		send: function(text){
			var headers = {'Content-Type': 'text/plain'}
			callback(null, {
				isBase64Encoded: false,
				statusCode: 200,
				headers: setVertexSession(req, headers, opts),
				headers: headers,
				body: text
			})
		},

		redirect: function(url){
			var headers = {'Location': url}
			callback(null, {
				isBase64Encoded: false,
				statusCode: 301, // redirect stat code
				headers: setVertexSession(req, headers, opts),
				headers: headers,
				body: url
			})
		},

		render: function(template, data){
			const basePath = __dirname.replace('node_modules/vertex360/dist/vertex', '')
			const pageName = template
			var partials = {}
			var mustacheFile = null
			var tplData = null

			// this promise never rejects. only returns null on err
			checkPageConfig(template, req.headers['Turbo-Vertex-App']) // header set in nginx reverse proxy
			.then(pageConfig => { // this can be null
				if (data==null)
					data = {}

				// page can be manually set by turbo.pageConfig()
				// although we are trying to move away from that:
				if (data.page == null){
					if (pageConfig != null)
						data['page'] = pageConfig
				}

				var vertexClient = req.headers['turbo-vertex-client']
				if (vertexClient != null){
					if (vertexClient == 'widget'){
						// send back only page data rather than populated html:
						var headers = {'Content-Type': 'application/json'}
						data['pageName'] = data.pageName || template // default to template name
	
						callback(null, {
							isBase64Encoded: false,
							statusCode: 200,
							headers: headers,
							body: JSON.stringify(data)
						})
	
						return
					}
				}
	
				tplData = data || {}	
				const filePath = basePath+'/'+viewsDir+'/'+pageName+'.mustache'
				return readFile(filePath)
			})
			.then(file => {
				mustacheFile = file
				const partialsPath = basePath+'/'+viewsDir+'/partials'
				return readRecursiveDirectories(partialsPath)
			})
			.then(files => { // files from partials directory
				files.forEach(function(fileInfo, i){ // {name:'...', path:'...'}
					// if (fileName.indexOf('.mustache') > -1) // mustache files only
					// 	partials[fileName.split('.')[0]] = fs.readFileSync(basePath+'/'+viewsDir+'/partials/'+fileName, 'utf8')

					// fileInfo -- {name:'footer', path:'views/partials/footer.mustache'}
					if (fileInfo.path.indexOf('.mustache') > -1){ // mustache files only
						partials[fileInfo.name] = fs.readFileSync(fileInfo.path, 'utf8')
					}
				})

				return renderMustache({template:mustacheFile, data:tplData, partials:partials})
			})
			.then(html => {
				var headers = {'Content-Type': 'text/html'}
				callback(null, {
					isBase64Encoded: false,
					statusCode: 200,
					headers: setVertexSession(req, headers, opts),
					body: html
				})

				return
			})
			.catch(err => {
				callback(null, {
					isBase64Encoded: false,
					statusCode: 404,
					headers: {'Content-Type': 'application/json'},
					body: JSON.stringify({
						confirmation: 'fail',
						message: err.message
					})
				})

				return
			})
		}
	}

	return res
}

const clearSession = function(){
	shouldClearSession = true
}

const bindMiddleware = function(req, res, middlewareArray){
	return new Promise((resolve, reject) => {
		if (middlewareArray==null){
			resolve({
				req: req,
				res: res
			})
			return
		}

		if (middlewareArray.length==0){
			resolve({
				req: req,
				res: res
			})
			return
		}

		let nextIndex = 0
		const callMiddlewares = function(){
			if (nextIndex < middlewareArray.length){
				const middleware = middlewareArray[nextIndex]
				middleware(req, res, () => {
					nextIndex += 1
					callMiddlewares()
				})
			}
			else {
				resolve({
					req: req,
					res: res
				})
				return
			}
		}

		callMiddlewares()
	})
}

module.exports = function(event, callback, routeParams, opts, middleware, done){ // 'opts' can be null, 'middleware' is an array
	var body = {}

	// parse POST body if founde:
	if (event.body != null){
		try { // this may come in as stringified json: "{\"name\":\"lebronjames\",\"email\":\"lebronjames@gmail.com\"}"
			body = JSON.parse(event.body)
		}
		catch(err){ // might be url-formatted: "name=dkwon&email=123" - this is how it comes back from a <form> field
			var parts = event.body.split('&')
			parts.forEach(function(keyValue, i){
				var keyValueParts = keyValue.split('=')
				if (keyValueParts.length == 2)
					body[keyValueParts[0]] = decode(keyValueParts[1])
			})
		}
	}

	var url = event.path

	var query = event.queryStringParameters || {}
	var keys = Object.keys(query)
	if (keys.length > 0){
		url += '?'
		keys.forEach(function(key, i){
			if (query[key])
				url += key+'='+query[key]
		})
	}

	var req = {
//		query: event.queryStringParameters || {},
		query: query,
		body: body,
		headers: event.headers,
		vertexSessionChanged: false,
		method: event.httpMethod.toUpperCase(),
//		url: event.path
		url: url
	}

	let cookieName = getCookieName(opts)
	var vertexSession = {reset: clearSession}
	// req['vertexSession'] = proxyVertexSession(vertexSession, req)
	req[cookieName] = proxyVertexSession(vertexSession, req)

	if (routeParams != null)
		req['params'] = routeParams.params

	// check cookies:
	var ck = event.headers['Cookie'] // "cookie": "_ga=GA1.2.1640725716.1495418605; _gid=GA1.2.1387035527.1508298483; vertexSession=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
	if (ck == null){
		const configuredResponse = configureResponse(req, callback, opts)

		bindMiddleware(req, configuredResponse, middleware)
		.then(data => {
			return done(null, {
				req: data.req,
				res: data.res
			})
		})
		.catch(err => {
			reject(err)
			return
		})

		return
	}

	// Parse cookies
	var cookies = cookie.parse(ck) // https://www.npmjs.com/package/cookie
	// if (cookies.vertexSession == null){
	if (cookies[cookieName] == null){
		const configuredResponse = configureResponse(req, callback, opts)

		bindMiddleware(req, configuredResponse, middleware)
		.then(data => {
			return done(null, {
				req: data.req,
				res: data.res
			})
		})
		.catch(err => {
			reject(err)
			return
		})

		return
	}


	// try to parse cookie:
	try {
		// const decoded = sessions.util.decode({cookieName:SESSION_COOKIE_NAME, secret:'abc'}, cookies.vertexSession)
		const decoded = sessions.util.decode({cookieName:cookieName, secret:'abc'}, cookies[cookieName])
		// looks like this: {content: "{\"user\":\"123\"}", createdAt: 1508874868373, duration: 86400000}

		if (decoded == null){ // failed, no session cookie
			const configuredResponse = configureResponse(req, callback, opts)
			bindMiddleware(req, configuredResponse, middleware)
			.then(data => {
				return done(null, {
					req: data.req,
					res: data.res
				})
			})
			.catch(err => {
				reject(err)
				return
			})

			return
		}

		if (decoded.content == null){ // failed, no session cookie
			const configuredResponse = configureResponse(req, callback, opts)
			bindMiddleware(req, configuredResponse, middleware)
			.then(data => {
				return done(null, {
					req: data.req,
					res: data.res
				})
			})
			.catch(err => {
				reject(err)
				return
			})

			return
		}

		var vertexSession = JSON.parse(decoded.content)
		vertexSession['reset'] = clearSession

		// req[SESSION_COOKIE_NAME] = proxyVertexSession(vertexSession, req)
		req[cookieName] = proxyVertexSession(vertexSession, req)
		const configuredResponse = configureResponse(req, callback, opts)

		bindMiddleware(req, configuredResponse, middleware)
		.then(data => {
			return done(null, {
				req: data.req,
				res: data.res
			})
		})
		.catch(err => {
			reject(err)
			return
		})
	}
	catch(err){
		// req[SESSION_COOKIE_NAME] = cookies.vertexSession
		req[cookieName] = cookies[cookieName]
		const configuredResponse = configureResponse(req, callback, opts)

		bindMiddleware(req, configuredResponse, middleware)
		.then(data => {
			return done(null, {
				req: data.req,
				res: data.res
			})
		})
		.catch(err => {
			reject(err)
			return
		})
	}

}
