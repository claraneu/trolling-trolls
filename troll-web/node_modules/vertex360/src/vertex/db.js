const path = require('path')
const fs = require('fs')
const TaskMgr = require('./TaskMgr')
const utils = require('./utils')
const { Document, connect } = require('../camo')

const BASE_DIR = __dirname + '/../../../../'
const TMP_DIR = process.env.TMP_DIR || '/tmp'
const LOCAL_DIR = path.join(BASE_DIR, TMP_DIR)

const loadCollection = ({collectionName, filePath, TURBO_APP_ID, TURBO_API_KEY}) => {
	return new Promise((resolve, reject) => {
		if (!collectionName) {
			reject(new Error('Collection name required.'))
			return
		}

		if (!TURBO_APP_ID) {
			reject(new Error('TURBO_APP_ID name required.'))
			return
		}

		if (TURBO_APP_ID==='<TURBO_APP_ID>') {
			reject(new Error('TURBO_APP_ID name required.'))
			return
		}

		if (!TURBO_API_KEY) {
			reject(new Error('TURBO_API_KEY name required.'))
			return
		}

		if (TURBO_API_KEY==='<TURBO_API_KEY>') {
			reject(new Error('TURBO_API_KEY name required.'))
			return
		}

		utils.fetchSite(TURBO_APP_ID)
		.then(site => {
			if (site.api.key != TURBO_API_KEY){
				reject(new Error('Unauthorized'))
				return
			}

			const dbFile = 'https://s3.amazonaws.com/turbo360-vertex/stores/'+site.slug+'/'+collectionName+'.txt'
			return utils.fetchTextFile(dbFile)
		})
		.then(data => {
            TaskMgr.setCompaction = collectionName
	        return utils.writeFile(filePath, data)
		})
		.then(data => {
			resolve(data)
			return
		})
		.catch(err => {
			reject(err)
		})
	})
}

const collectionFileChanged = (collectionName) => {
    return new Promise((resolve, reject) => {
		if (!collectionName) {
            resolve()
			return
		}

		if (collectionName.length === 0 || collectionName === '') {
            resolve()
			return
		}

        if (TaskMgr.dbRef) {
            // console.log('COMPACT DB: ' +JSON.stringify(Object.keys(TaskMgr.dbRef._collections.creators)))
            if (TaskMgr.dbRef._collections) {
                const collectionDB = TaskMgr.dbRef._collections[collectionName]
                if (collectionDB) {
					console.log('COMPACT DB FILE: '+collectionName)
                    collectionDB.persistence.compactDatafile()
				}
            }
        }

        // collection is already waiting to be synced,
        // don't add again and prevent task from posting:
        if (TaskMgr.sync[collectionName]) {
            resolve()
            return
        }

        TaskMgr.sync[collectionName] = true
        const now = new Date()
        TaskMgr.queue.push(now.toString()+' - sync collection: '+collectionName)

        // Send message to SQS. SQS Messages delay for 10 seconds which
        // "debounces" save requests in case these come in a loop:
        const body = {
            name: 'sync-collection',
            collection: collectionName,
            site: process.env.TURBO_APP_ID,
            slug: process.env.TURBO_APP_SLUG,
        }

        utils.post('https://platform.turbo360-vector.com/sqs/send', body, {'Accept': 'application/json', 'Content-Type': 'application/json'})
        .then(data => {
            resolve(data)
        })
        .catch(err => {
            console.log('sync-collection err: '+err)
            console.log('sync-collection err: '+JSON.stringify(body))
            reject(err)
        })
    })
}

const setCompactionInterval = () => {
	if (TaskMgr.setCompaction === null)
		return

	// console.log('SET COMPACTION: '+TaskMgr.setCompaction)
	if (!TaskMgr.dbRef._collections) {
		TaskMgr.setCompaction = null
		return
	}

	// ["inMemoryOnly","autoload","timestampData","filename","compareStrings","persistence","executor","indexes","ttlIndexes"]
	const collectionDB = TaskMgr.dbRef._collections[TaskMgr.setCompaction]
	if (!collectionDB) {
		TaskMgr.setCompaction = null
		return
	}

	collectionDB.persistence.setAutocompactionInterval(5000)
	TaskMgr.setCompaction = null
}

class Model extends Document {
    constructor(name) {
        super()
    }

    preFetch() {
        const that = this;
        return new Promise((resolve, reject) => {
			const {TURBO_ENV, TURBO_APP_ID, TURBO_API_KEY, TURBO_APP_SLUG} = process.env

			const collectionName = that.collectionName()
			const filePath = (TURBO_ENV=='dev') ? `${LOCAL_DIR}/${collectionName}.db` : `${TMP_DIR}/${collectionName}.db`
            // console.log('THIS IS A PREFETCH HOOK: ' + filePath)

			// check env file for valid Turbo site. if valid,
			// load collection db file if necessary from S3.
			if (fs.existsSync(filePath)){
				// console.log('collection file found')
				resolve()
				return
			}

			loadCollection({collectionName, filePath, TURBO_API_KEY, TURBO_APP_ID})
			.then(data => {
				resolve(data)
			})
			.catch(err => {
				reject(err)
			})
        })
    }

    postFetch() {
		setCompactionInterval()
    }

    preSave() {
        // console.log('PRE SAVE HOOK: '+this.collectionName())
        if (process.env.TURBO_ENV !== 'prod')
            return

        const that = this;
        return new Promise((resolve, reject) => {
            collectionFileChanged(that.collectionName())
            .then(data => {
				// console.log('PRE SAVE HOOK RESOLVE')
                resolve(data)
            })
            .catch(err => {
                reject(err)
            })
        })
    }

    postSave() {
		setCompactionInterval()
	}

    preDelete() {
        // console.log('PRE DELETE HOOK: '+this.collectionName())
        if (process.env.TURBO_ENV !== 'prod')
            return

        const that = this;
        return new Promise((resolve, reject) => {
            collectionFileChanged(that.collectionName())
            .then(data => {
                resolve(data)
            })
            .catch(err => {
                reject(err)
            })
        })
    }

    postDelete() {
		setCompactionInterval()
	}
}

const nedbConnect = (dbUri, onError, onSuccess) => {
	let database;

	connect(dbUri).then(db => {
		// console.log('DB initialized: ' + JSON.stringify(db))
		TaskMgr.dbRef = db
		database = db
		onSuccess()
		return
	})
	.catch(err => {
		console.log('DB ERROR: ' + err.message)
		onError(err)
		return
	})
}

module.exports = {
    Model: Model,

	connect: (dbUri, onError, onSuccess) => {
		nedbConnect(dbUri, onError, onSuccess)
	},

	connectNedb: (dbUri, onError, onSuccess) => {
		nedbConnect(dbUri, onError, onSuccess)
	},

	nedbConfig: (url, successCallback, errCallback) => {
		return {
			url: url,
	    	type: 'nedb',
			onError: (err) => {
				if (errCallback == null)
					console.log('DB Connection Failed!')
				else
					errCallback(err)
			},
			onSuccess: () => {
				if (successCallback == null)
					console.log('DB Successfully Connected!')
				else
					successCallback()
			}
		}
    },
    
    nedb: (successCallback, errCallback) => {
        const tempDir = process.env.TMP_DIR || '/tmp'
        const dbUrl = (process.env.TURBO_ENV=='dev') ? 'nedb://'+path.join(BASE_DIR, tempDir) : 'nedb://'+tempDir
        // console.log('DB_URL: ' + dbUrl)

		return {
			url: dbUrl,
	    	type: 'nedb',
			onError: (err) => {
				if (errCallback == null)
					console.log('DB Connection Failed!')
				else
					errCallback(err)
			},
			onSuccess: () => {
				if (successCallback == null)
					console.log('DB Successfully Connected!')
				else
					successCallback()
			}
		}
    }
}
